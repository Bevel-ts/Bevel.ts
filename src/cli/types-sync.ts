#!/usr/bin/env bun
import { Project, SyntaxKind } from "ts-morph";
import { writeFile, mkdir } from "fs/promises";
import { existsSync } from "fs";
import path from "path";
import chalk from "chalk";

const generatedFile = "src/types/generated.ts";
const schemasPath = "src/schemas/**/*.ts";
const routesPath = "src/routes/**/*.ts";
const force = process.argv.includes("--force");

const project = new Project();
project.addSourceFilesAtPaths([schemasPath, routesPath]);

function tsType(zodType: string): string {
  switch (zodType) {
    case "string":
      return "string";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    default:
      return "any";
  }
}

async function main() {
  if (existsSync(generatedFile) && !force) {
    console.log(chalk.yellow("⚠️ 既に /types/generated.ts が存在します。--force を指定して上書きできます。"));
    return;
  }

  const schemaTypes: string[] = [];
  const apiEntries: string[] = [];

  // Zodから型抽出
  // スキーマ型定義抽出
for (const file of project.getSourceFiles(schemasPath)) {
  const objects = file.getVariableDeclarations();

  for (const decl of objects) {
    const name = decl.getName();

    if (!name.endsWith("Schema")) continue;

    const objLiteral = decl.getInitializerIfKind(SyntaxKind.ObjectLiteralExpression);
    if (!objLiteral) continue;

    const inputProp = objLiteral.getProperty("input");
    const outputProp = objLiteral.getProperty("output");

    const inputFields = getFieldsFromZodObject(inputProp);
    const outputFields = getFieldsFromZodObject(outputProp);

    schemaTypes.push(`export type ${name.replace("Schema", "Input")} = {\n${inputFields}\n}`);
    schemaTypes.push(`export type ${name.replace("Schema", "Output")} = {\n${outputFields}\n}`);
  }
}
function getFieldsFromZodObject(prop: any): string {
  const assignments = prop?.getDescendantsOfKind(SyntaxKind.PropertyAssignment) ?? [];
  const fieldLines = assignments.map(p => {
    const key = p.getName();
    const typeText = p.getInitializerOrThrow().getText().split(".")[1]?.split("(")[0];
    return `  ${key}: ${tsType(typeText)}`;
  });
  return fieldLines.join("\n");
}

  // defineRoute() から API 情報抽出
  for (const file of project.getSourceFiles(routesPath)) {
    const routeVar = file.getVariableDeclarations().find(d =>
      d.getInitializer()?.getText().includes("defineRoute")
    );
    if (!routeVar) continue;

    const name = routeVar.getName().replace("Route", "");
    const text = routeVar.getInitializer()?.getText() || "";

    const methodMatch = text.match(/method:\s*["'](\w+)["']/);
    const pathMatch = text.match(/path:\s*["']([^"']+)["']/);
    const inputMatch = text.match(/input:\s*(\w+)/);
    const outputMatch = text.match(/output:\s*(\w+)/);

    if (!methodMatch || !pathMatch || !inputMatch || !outputMatch) continue;

    apiEntries.push(`  ${name.toLowerCase()}: {
    create: {
      method: '${methodMatch[1].toUpperCase()}',
      path: '${pathMatch[1]}',
      input: '${inputMatch[1]}',
      output: '${outputMatch[1]}'
    }
  }`);
  }

  const out = `// Auto-generated by bevel types sync

${schemaTypes.join("\n\n")}

export const api = {
${apiEntries.join(",\n")}
}
`;

  await mkdir(path.dirname(generatedFile), { recursive: true });
  await writeFile(generatedFile, out);
  console.log(chalk.green(`✅ 型を生成しました: ${generatedFile}`));
}

main().catch(e => {
  console.error(chalk.red("❌ 型生成中にエラー:"), e);
});
